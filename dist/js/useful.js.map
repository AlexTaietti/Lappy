{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./tmp/js/Lappy.js","webpack:///./tmp/js/useful.js"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFa;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,uBAAuB,2BAA2B,2EAA2E,kCAAkC,mBAAmB,GAAG,EAAE,OAAO,kCAAkC,8HAA8H,GAAG,EAAE,qBAAqB;;AAExX,0CAA0C,+DAA+D,2EAA2E,EAAE,yEAAyE,eAAe,sDAAsD,EAAE,EAAE,uDAAuD;;AAE/X,gCAAgC,4EAA4E,iBAAiB,UAAU,GAAG,8BAA8B;;AAExK,gCAAgC,6DAA6D,yCAAyC,8CAA8C,iCAAiC,mDAAmD,yDAAyD,EAAE,OAAO,uCAAuC,EAAE,iDAAiD,GAAG;;AAEva,iDAAiD,0EAA0E,aAAa,EAAE,qCAAqC;;AAE/K,uCAAuC,uBAAuB,uFAAuF,EAAE,aAAa;;AAEpK,sCAAsC,wEAAwE,0CAA0C,8CAA8C,MAAM,wEAAwE,GAAG,aAAa,EAAE,YAAY,cAAc,EAAE;;AAElU,6BAA6B,gGAAgG,gDAAgD,GAAG,2BAA2B;;AAE3M,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE;;AAE3T,6DAA6D,sEAAsE,8DAA8D,oBAAoB;;AAErN;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,0DAA0D;;AAE1D;AACA,uDAAuD;;AAEvD;AACA,GAAG;AACH;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,kCAAkC;AACzD;AACA;AACA;AACA,KAAK;;AAEL,GAAG;AACH;AACA;AACA;AACA,KAAK;;AAEL,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;;AAEL,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;;AAED;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,0DAA0D;;AAE1D,4BAA4B;;AAE5B;AACA;AACA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;;AAED;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA,oDAAoD;;AAEpD,wBAAwB;;AAExB;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,gCAAgC;AACrD;AACA;AACA,KAAK;;AAEL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,GAAG;;AAEH;AACA,CAAC;;AAED;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;AACA,KAAK;;AAEL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL,GAAG;AACH;AACA;AACA,qBAAqB,gCAAgC;AACrD;AACA;AACA,KAAK;;AAEL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA,qBAAqB,gCAAgC;AACrD;AACA;AACA,KAAK;;AAEL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,gCAAgC;AACrD;;AAEA,uBAAuB,yCAAyC;AAChE;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,CAAC,GAAG;AACJ;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA,CAAC;;;AAGD;AACA;AACA,CAAC;;;AAGD;AACA;AACA,C;;;;;;;;;;;;AC/da;;AAEb,aAAa,mBAAO,CAAC,qCAAY;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,CAAC,EAAE;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD,UAAU,I","file":"useful.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./tmp/js/useful.js\");\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Lappy = exports.ActiveOverlapObject = exports.BasicOverlapObject = exports.GraphicalTest = void 0;\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar GraphicalTest = /*#__PURE__*/function () {\n  function GraphicalTest() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, GraphicalTest);\n\n    var defaults = {\n      context: undefined,\n      approachColor: 'red'\n    };\n    var completeOptions = mergeObjects(defaults, options); // context options (more coming soon!)\n\n    this.context = completeOptions.context;\n    this.approachColor = completeOptions.approachColor; // paused flag\n\n    this.paused = false;\n  } // display the coordinates of each vertex of the target (aka the current element) relative to the document's top left corner\n  // basically the space used to represent the elements is the inverse first quadrant of a 2D plane\n\n\n  _createClass(GraphicalTest, [{\n    key: \"displayCoordinates\",\n    value: function displayCoordinates(target) {\n      this.context.beginPath();\n      this.context.fillStyle = \"black\";\n      this.context.textAlign = \"center\";\n      this.context.textBaseline = \"middle\";\n      this.context.fillText(\"x:\".concat(~~target.htmlCoordinates[0].x, \", y:\").concat(~~target.htmlCoordinates[0].y), ~~target.htmlCoordinates[0].x, ~~target.htmlCoordinates[0].y - 15);\n      this.context.fillText(\"x:\".concat(~~target.htmlCoordinates[1].x, \", y:\").concat(~~target.htmlCoordinates[1].y), ~~target.htmlCoordinates[1].x, ~~target.htmlCoordinates[1].y - 15);\n      this.context.fillText(\"x:\".concat(~~target.htmlCoordinates[2].x, \", y:\").concat(~~target.htmlCoordinates[2].y), ~~target.htmlCoordinates[2].x, ~~target.htmlCoordinates[2].y + 15);\n      this.context.fillText(\"x:\".concat(~~target.htmlCoordinates[3].x, \", y:\").concat(~~target.htmlCoordinates[3].y), ~~target.htmlCoordinates[3].x, ~~target.htmlCoordinates[3].y + 15);\n      this.context.closePath();\n    } // draw a dashed line on the outer area of the object\n\n  }, {\n    key: \"drawApproachArea\",\n    value: function drawApproachArea(target) {\n      this.context.beginPath();\n      this.context.strokeStyle = this.approachColor;\n      this.context.setLineDash([5, 10]);\n      this.context.strokeRect(target.coordinates[0].x, target.coordinates[0].y, target.coordinates[2].x - target.coordinates[0].x, target.coordinates[2].y - target.coordinates[0].y);\n      this.context.stroke();\n      this.context.closePath();\n    } // display the target on the graphical test canvas\n\n  }, {\n    key: \"display\",\n    value: function display(target) {\n      this.displayCoordinates(target);\n      if (target.offset.x || target.offset.y) this.drawApproachArea(target);\n\n      if (target.active && target.trackedObjects.length) {\n        for (var i = 0; i < target.trackedObjects.length; i++) {\n          this.display(target.trackedObjects[i].object);\n        }\n      }\n    } // clear the graphical test's display\n\n  }, {\n    key: \"clearTestDisplay\",\n    value: function clearTestDisplay() {\n      this.context.clearRect(0, 0, this.context.canvas.width, this.context.canvas.height);\n    } // pause graphical test\n\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      this.clearTestDisplay();\n      this.paused = true;\n    } // resume graphical test\n\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      this.paused = false;\n    }\n  }]);\n\n  return GraphicalTest;\n}();\n\nexports.GraphicalTest = GraphicalTest;\n\nvar BasicOverlapObject = /*#__PURE__*/function () {\n  function BasicOverlapObject(htmlElement) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, BasicOverlapObject);\n\n    var defaults = {\n      offset: {\n        x: 0,\n        y: 0\n      },\n      axis: {\n        x: true,\n        y: true\n      }\n    };\n    var completeOptions = mergeObjects(defaults, options); // object's HTML\n\n    this.HTML = htmlElement; // object data\n\n    this.offset = completeOptions.offset;\n    this.axis = completeOptions.axis;\n    this.active = false;\n    this.htmlCoordinates = getInnerCoords(htmlElement);\n    this.coordinates = getOuterCoords(htmlElement, completeOptions.offset, completeOptions.axis);\n  } // update both the coordinates of the actual HTML element as well as the imaginary offset bounding box surrounding it\n\n\n  _createClass(BasicOverlapObject, [{\n    key: \"updateCoordinates\",\n    value: function updateCoordinates() {\n      this.htmlCoordinates = getInnerCoords(this.HTML);\n      this.coordinates = getOuterCoords(this.HTML, this.offset, this.axis);\n    }\n  }]);\n\n  return BasicOverlapObject;\n}();\n\nexports.BasicOverlapObject = BasicOverlapObject;\n\nvar ActiveOverlapObject = /*#__PURE__*/function (_BasicOverlapObject) {\n  _inherits(ActiveOverlapObject, _BasicOverlapObject);\n\n  var _super = _createSuper(ActiveOverlapObject);\n\n  function ActiveOverlapObject(htmlElement) {\n    var _this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, ActiveOverlapObject);\n\n    // invoke super class constructor (aka BasicOverlapObject's constructor)\n    _this = _super.call(this, htmlElement, options); // this boi is active\n\n    _this.active = true; // passive objects this boiii can interact with\n\n    _this.trackedObjects = [];\n    return _this;\n  } // update the active element's coordinates as well as the coordinates of the basic objects it may interact with\n\n\n  _createClass(ActiveOverlapObject, [{\n    key: \"updateCoordinates\",\n    value: function updateCoordinates() {\n      this.htmlCoordinates = getInnerCoords(this.HTML);\n      this.coordinates = getOuterCoords(this.HTML, this.offset, this.axis);\n\n      for (var i = 0; i < this.trackedObjects.length; i++) {\n        this.trackedObjects[i].object.updateCoordinates();\n      }\n    } // add a new basic object this active one can interact with (can also be an HTML collection)\n\n  }, {\n    key: \"addTrackedObject\",\n    value: function addTrackedObject(overlapObject) {\n      var callbacks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      // default callbacks\n      var defaultCallbacks = {\n        onApproach: function onApproach(main, check) {\n          return 1;\n        },\n        onOverlap: function onOverlap(main, check) {\n          return 1;\n        },\n        onExit: function onExit(main, check) {\n          return 1;\n        },\n        onLeave: function onLeave(main, check) {\n          return 1;\n        }\n      };\n\n      if (overlapObject.length) {\n        for (var i = 0; i < overlapObject.length; i++) {\n          this.trackedObjects.push({\n            object: overlapObject instanceof BasicOverlapObject ? overlapObject : new BasicOverlapObject(overlapObject[i], options),\n            callbacks: mergeObjects(defaultCallbacks, callbacks),\n            lastOverlapData: {\n              x: undefined,\n              y: undefined\n            }\n          });\n        }\n      } else {\n        this.trackedObjects.push({\n          object: overlapObject instanceof BasicOverlapObject ? overlapObject : new BasicOverlapObject(overlapObject, options),\n          callbacks: mergeObjects(defaultCallbacks, callbacks),\n          lastOverlapData: {\n            x: undefined,\n            y: undefined\n          }\n        });\n      }\n    }\n  }]);\n\n  return ActiveOverlapObject;\n}(BasicOverlapObject);\n\nexports.ActiveOverlapObject = ActiveOverlapObject;\n\nvar Lappy = /*#__PURE__*/function () {\n  function Lappy() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Lappy);\n\n    if (options.graphicalTest) this.graphicalTest = new GraphicalTest(options.graphicalTest);\n    this.overlapObjects = [];\n  } // add one more active object to be tracked by Lappy\n\n\n  _createClass(Lappy, [{\n    key: \"addActiveObject\",\n    value: function addActiveObject(newOverlapObject) {\n      this.overlapObjects.push(newOverlapObject);\n    } // resize the graphical test canvas' dimensions (to be called whenever the window is resized)\n\n  }, {\n    key: \"resizeGraphicalTestCanvas\",\n    value: function resizeGraphicalTestCanvas() {\n      this.graphicalTest.context.canvas.width = getDocumentWidth();\n      this.graphicalTest.context.canvas.height = getDocumentHeight();\n    }\n  }, {\n    key: \"checkOverlapY\",\n    value: function checkOverlapY(main, check) {\n      if (main.htmlCoordinates[2].y - check.htmlCoordinates[0].y >= 0 && main.htmlCoordinates[2].y - check.htmlCoordinates[2].y <= 0) {\n        return 1;\n      }\n\n      if (main.htmlCoordinates[0].y - check.htmlCoordinates[2].y <= 0 && main.htmlCoordinates[0].y - check.htmlCoordinates[0].y >= 0) {\n        return -1;\n      }\n\n      if (main.coordinates[2].y - check.coordinates[0].y >= 0 && main.coordinates[2].y - check.coordinates[2].y <= 0) {\n        return 2;\n      }\n\n      if (main.coordinates[0].y - check.coordinates[2].y <= 0 && main.coordinates[0].y - check.coordinates[0].y >= 0) {\n        return -2;\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"checkOverlapX\",\n    value: function checkOverlapX(main, check) {\n      if (main.htmlCoordinates[2].x - check.htmlCoordinates[0].x >= 0 && main.htmlCoordinates[2].x - check.htmlCoordinates[2].x <= 0) {\n        return 1;\n      }\n\n      if (main.htmlCoordinates[0].x - check.htmlCoordinates[2].x <= 0 && main.htmlCoordinates[0].x - check.htmlCoordinates[0].x >= 0) {\n        return -1;\n      }\n\n      if (main.coordinates[2].x - check.coordinates[0].x >= 0 && main.coordinates[2].x - check.coordinates[2].x <= 0) {\n        return 2;\n      }\n\n      if (main.coordinates[0].x - check.coordinates[2].x <= 0 && main.coordinates[0].x - check.coordinates[0].x >= 0) {\n        return -2;\n      }\n\n      return 0;\n    } // update every active object's coordinates (which will in turn update every one of its basic objects' coordinates)\n\n  }, {\n    key: \"updateCoordinates\",\n    value: function updateCoordinates() {\n      for (var i = 0; i < this.overlapObjects.length; i++) {\n        this.overlapObjects[i].updateCoordinates();\n      }\n    } // detect any overlap between a target object (active) and a check (basic)\n\n  }, {\n    key: \"calculateOverlap\",\n    value: function calculateOverlap(main, check) {\n      var overlapX = this.checkOverlapX(main, check);\n      var overlapY = this.checkOverlapY(main, check);\n      return {\n        x: main.axis.x ? overlapX : overlapY,\n        y: main.axis.y ? overlapY : overlapX\n      };\n    } // for now if neither of the two objects involved in the overlap have an offset property the only two callbacks executed will be \"onOverlap\" and \"onLeave\" (\"definitely something I'll fix soon!\")\n\n  }, {\n    key: \"checkOverlap\",\n    value: function checkOverlap(main, check) {\n      var overlap = this.calculateOverlap(main, check.object);\n\n      if (overlap.x && overlap.y) {\n        if (Math.abs(overlap.x) === Math.abs(overlap.y)) {\n          if (overlap.x % 2 === 0 && overlap.y % 2 === 0) {\n            if ((overlap.x + check.lastOverlapData.x) % 3 === 0 && overlap.x * check.lastOverlapData.x > 0 && overlap.x % 2 === 0 || (overlap.y + check.lastOverlapData.y) % 3 === 0 && overlap.y * check.lastOverlapData.y > 0 && overlap.y % 2 === 0) {\n              check.callbacks.onExit(main.HTML, check.object.HTML);\n            } else {\n              check.callbacks.onApproach(main.HTML, check.object.HTML);\n            }\n          } else {\n            check.callbacks.onOverlap(main.HTML, check.object.HTML);\n          }\n        } else if (overlap.x % 2 === 0 || overlap.y % 2 === 0) {\n          if ((overlap.x + check.lastOverlapData.x) % 3 === 0 && overlap.x * check.lastOverlapData.x > 0 && overlap.x % 2 === 0 || (overlap.y + check.lastOverlapData.y) % 3 === 0 && overlap.y * check.lastOverlapData.y > 0 && overlap.y % 2 === 0) {\n            check.callbacks.onExit(main.HTML, check.object.HTML);\n          } else {\n            check.callbacks.onApproach(main.HTML, check.object.HTML);\n          }\n        }\n      } else if ((!overlap.x || !overlap.y) && check.lastOverlapData.x && check.lastOverlapData.y) {\n        check.callbacks.onLeave(main.HTML, check.object.HTML);\n      }\n\n      check.lastOverlapData = overlap;\n    }\n  }, {\n    key: \"displayGraphicalTest\",\n    value: function displayGraphicalTest() {\n      this.updateCoordinates();\n      this.graphicalTest.clearTestDisplay();\n\n      for (var i = 0; i < this.overlapObjects.length; i++) {\n        this.graphicalTest.display(this.overlapObjects[i]);\n      }\n    } // initialise a graphical test for Lappy's current instance\n\n  }, {\n    key: \"addGraphicalTest\",\n    value: function addGraphicalTest(graphicalTestData) {\n      if (!this.graphicalTest) {\n        this.graphicalTest = new GraphicalTest(graphicalTestData);\n        this.resizeGraphicalTestCanvas();\n      } else {\n        throw 'Graphical test already initialised!';\n      }\n    } // This is how the Lappy dooo...\n\n  }, {\n    key: \"watch\",\n    value: function watch() {\n      this.updateCoordinates();\n\n      if (this.graphicalTest && !this.graphicalTest.paused) {\n        this.displayGraphicalTest();\n      }\n\n      for (var i = 0; i < this.overlapObjects.length; i++) {\n        var currentActive = this.overlapObjects[i];\n\n        for (var r = 0; r < currentActive.trackedObjects.length; r++) {\n          this.checkOverlap(currentActive, currentActive.trackedObjects[r]);\n        }\n      }\n    }\n  }]);\n\n  return Lappy;\n}(); ///////////////////////////\n// FUNCTIONS & VARIABLES //\n///////////////////////////\n// get an HTML element's variables\n\n\nexports.Lappy = Lappy;\n\nfunction getInnerCoords(element) {\n  var coords = [],\n      w = element.offsetWidth,\n      h = element.offsetHeight;\n  coords[0] = {\n    y: element.getBoundingClientRect().y + window.scrollY,\n    x: element.getBoundingClientRect().x + window.scrollX\n  };\n  coords[1] = {\n    y: element.getBoundingClientRect().y + window.scrollY,\n    x: element.getBoundingClientRect().x + window.scrollX + w\n  };\n  coords[2] = {\n    y: element.getBoundingClientRect().y + window.scrollY + h,\n    x: element.getBoundingClientRect().x + window.scrollX + w\n  };\n  coords[3] = {\n    y: element.getBoundingClientRect().y + window.scrollY + h,\n    x: element.getBoundingClientRect().x + window.scrollX\n  };\n  return coords;\n} // get an overlapObject's outer apprach area's coordinates\n\n\nfunction getOuterCoords(element) {\n  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var axis = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    x: undefined,\n    y: undefined\n  };\n  var coords = [],\n      w = element.offsetWidth,\n      h = element.offsetHeight;\n  coords[0] = {\n    y: axis.y ? element.getBoundingClientRect().y + window.scrollY - offset.y : 0,\n    x: axis.x ? element.getBoundingClientRect().x + window.scrollX - offset.x : 0\n  };\n  coords[1] = {\n    y: axis.y ? element.getBoundingClientRect().y + window.scrollY - offset.y : 0,\n    x: axis.x ? element.getBoundingClientRect().x + window.scrollX + w + offset.x : window.innerWidth\n  };\n  coords[2] = {\n    y: axis.y ? element.getBoundingClientRect().y + window.scrollY + h + offset.y : window.innerHeight,\n    x: axis.x ? element.getBoundingClientRect().x + window.scrollX + w + offset.x : window.innerWidth\n  };\n  coords[3] = {\n    y: axis.y ? element.getBoundingClientRect().y + window.scrollY + h + offset.y : window.innerHeight,\n    x: axis.x ? element.getBoundingClientRect().x + window.scrollX - offset.x : 0\n  };\n  return coords;\n} // merge two objects by replacing each of the target's properties with the corresponding object's property if defined otherwise keep the target as is\n\n\nfunction mergeObjects(target, object, deep) {\n  for (var prop in target) {\n    if (object.hasOwnProperty(prop)) {\n      if (_typeof(object[prop]) === \"object\") {\n        if (deep) {\n          mergeObjects(target[prop], object[prop], true);\n        } else {\n          target[prop] = object[prop];\n        }\n      } else {\n        target[prop] = object[prop];\n      }\n    }\n  }\n\n  return target;\n} // get the document's height cross browser reliably\n\n\nfunction getDocumentHeight() {\n  return Math.max(document.documentElement.clientHeight, document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight);\n} // get the document's width cross browser reliably\n\n\nfunction getDocumentWidth() {\n  return Math.max(document.documentElement.clientWidth, document.body.scrollWidth, document.documentElement.scrollWidth, document.body.offsetWidth, document.documentElement.offsetWidth);\n}","\"use strict\";\n\nvar _Lappy = require(\"./Lappy.js\");\n\n//import Lappy\n//window.onload = function () {\n//toggle an element's css class\nfunction toggleClass(element, CSSClass) {\n  if (element.classList.contains(CSSClass)) {\n    element.classList.remove(CSSClass);\n  } else {\n    element.classList.add(CSSClass);\n  }\n}\n\nvar $ = document.querySelector.bind(document);\nvar $$ = document.querySelectorAll.bind(document);\nvar $hamburger = $(\".header__hamburger\");\nvar $hamburgerInner = $(\".hamburger__inner\");\nvar $navigation = $(\".navigation\");\nvar $header = $(\".header\");\nvar $$badContrast = $$(\".content__section:nth-child(even)\");\nvar headerOverlap = new _Lappy.ActiveOverlapObject($header);\nheaderOverlap.addTrackedObject($$badContrast, {\n  onOverlap: function onOverlap(main, check) {\n    $header.classList.add('scrolled');\n    $navigation.classList.add('scrolled');\n  },\n  onLeave: function onLeave(main, check) {\n    $header.classList.remove('scrolled');\n    $navigation.classList.remove('scrolled');\n  }\n}); //console.log(headerOverlap.trackedObjects[0].callbacks.onLeave.toString());\n\nvar L = new _Lappy.Lappy();\nL.addActiveObject(headerOverlap);\n\n$hamburger.onclick = function () {\n  toggleClass($hamburger, 'is-active');\n  toggleClass($navigation, 'is-open');\n};\n\nwindow.addEventListener('scroll', function () {\n  L.watch();\n});\nL.watch(); //}"],"sourceRoot":""}